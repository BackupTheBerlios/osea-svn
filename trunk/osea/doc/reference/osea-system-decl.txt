<FUNCTION>
<NAME>oseaserver_log_write</NAME>
<RETURNS>void  </RETURNS>
gchar * log_msg, ...
</FUNCTION>
<FUNCTION>
<NAME>oseaserver_log_vwrite</NAME>
<RETURNS>void  </RETURNS>
gchar * log_msg, va_list args
</FUNCTION>
<FUNCTION>
<NAME>oseaserver_log_check_and_disable_glog</NAME>
<RETURNS>void  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>oseaserver_reg_register</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *server_name, gint version_number, OseaClientNulFunc usr_function
</FUNCTION>
<FUNCTION>
<NAME>oseaserver_reg_unregister</NAME>
<RETURNS>gboolean  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>oseaserver_print_version_info</NAME>
<RETURNS>void  </RETURNS>

</FUNCTION>
<MACRO>
<NAME>OSEASERVER_MAIN_NO_EXTRA_OPTION</NAME>
#define OSEASERVER_MAIN_NO_EXTRA_OPTION oseaserver_main_no_extra_options ()
</MACRO>
<USER_FUNCTION>
<NAME>OseaServerMainCallback</NAME>
<RETURNS>void </RETURNS>
void
</USER_FUNCTION>
<FUNCTION>
<NAME>oseaserver_main_run_server</NAME>
<RETURNS>void  </RETURNS>
gchar                * server_name,gchar                * server_description,gchar                * server_version,glong                  server_compilation_date,gint                 * argc,gchar               ** argv[],gchar                * config_file,gchar                * accepted_keys[],OseaServerServicesProvided   services_provided[],gint                   services_version,AfgsMainCallback       check_function,struct poptOption    * server_extra_popt_option
</FUNCTION>
<FUNCTION>
<NAME>oseaserver_main_abort</NAME>
<RETURNS>void  </RETURNS>
gchar * format, ...
</FUNCTION>
<FUNCTION>
<NAME>oseaserver_afkeys_parse_and_check</NAME>
<RETURNS>OseaServerAfKey   *</RETURNS>
gchar     * af_key
</FUNCTION>
<FUNCTION>
<NAME>oseaserver_afkeys_destroy</NAME>
<RETURNS>void  </RETURNS>
OseaServerAfKey * af_key,gboolean     free_permission_list
</FUNCTION>
<FUNCTION>
<NAME>oseaserver_afkeys_set_connection_key_simple</NAME>
<RETURNS>void  </RETURNS>
RRConnection *connection,OseaServerAfKey    *af_key
</FUNCTION>
<FUNCTION>
<NAME>oseaserver_afkeys_set_connection_key</NAME>
<RETURNS>gboolean  </RETURNS>
OseaCommXmlServiceData * data,gpointer               user_data,RRChannel            * channel,gint                   msg_no
</FUNCTION>
<FUNCTION>
<NAME>oseaserver_afkeys_get_connection_key</NAME>
<RETURNS>OseaServerAfKey   *</RETURNS>
RRConnection * connection
</FUNCTION>
<FUNCTION>
<NAME>oseaserver_afkeys_is_current</NAME>
<RETURNS>gboolean  </RETURNS>
gchar * af_key
</FUNCTION>
<FUNCTION>
<NAME>oseaserver_afkeys_check_service_permission</NAME>
<RETURNS>gboolean  </RETURNS>
RRChannel * channel, gchar * service_name, gint msg_no
</FUNCTION>
<FUNCTION>
<NAME>oseaserver_signal_handler_init</NAME>
<RETURNS>void  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>oseaserver_message_error_answer</NAME>
<RETURNS>void  </RETURNS>
RRChannel * channel, gint msg_no, gchar * message,OseaCommCodeType status_code
</FUNCTION>
<FUNCTION>
<NAME>oseaserver_message_ok_answer</NAME>
<RETURNS>void  </RETURNS>
RRChannel * channel, gint msg_no, gchar * message,OseaCommCodeType status_code, ...
</FUNCTION>
<FUNCTION>
<NAME>oseaserver_message_check_params</NAME>
<RETURNS>GList          *</RETURNS>
OseaCommXmlServiceData * data, ...
</FUNCTION>
<FUNCTION>
<NAME>oseaserver_database_init</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *connection_name,const gchar *connection_description,gint argc,gchar **argv
</FUNCTION>
<FUNCTION>
<NAME>oseaserver_database_new_connection</NAME>
<RETURNS>GdaConnection  *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>oseaserver_database_quit</NAME>
<RETURNS>gboolean  </RETURNS>

</FUNCTION>
<MACRO>
<NAME>OSEASERVER_SERVICES_TABLE_END</NAME>
#define OSEASERVER_SERVICES_TABLE_END {NULL, NULL, NULL,  FALSE, NULL, NULL}
</MACRO>
<FUNCTION>
<NAME>oseaserver_services_set</NAME>
<RETURNS>void  </RETURNS>
OseaServerServicesProvided * services
</FUNCTION>
<FUNCTION>
<NAME>oseaserver_services_get</NAME>
<RETURNS>GList                 *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>oseaserver_services_get_dataset</NAME>
<RETURNS>OseaCommDataSet         *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>oseaserver_services_process</NAME>
<RETURNS>gboolean  </RETURNS>
OseaCommXmlServiceData * data, RRChannel * channel, gint msg_no
</FUNCTION>
<FUNCTION>
<NAME>oseaserver_services_update</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *server_name, const gchar *server_description, gint version_number
</FUNCTION>
<FUNCTION>
<NAME>oseaserver_command_execute_non_query</NAME>
<RETURNS>gboolean  </RETURNS>
gchar * cmd_string, ...
</FUNCTION>
<FUNCTION>
<NAME>oseaserver_command_execute_single_query</NAME>
<RETURNS>OseaCommDataSet  *</RETURNS>
gchar * cmd_string, ...
</FUNCTION>
<FUNCTION>
<NAME>oseaserver_config_load</NAME>
<RETURNS>OseaServerConfiguration  *</RETURNS>
gchar *filename, gchar ** accepted_keys
</FUNCTION>
<FUNCTION>
<NAME>oseaserver_config_get</NAME>
<RETURNS>gchar              *</RETURNS>
OseaServerConfiguration *config, gchar *key
</FUNCTION>
<FUNCTION>
<NAME>oseaserver_config_destroy</NAME>
<RETURNS>void  </RETURNS>
OseaServerConfiguration *config
</FUNCTION>
<FUNCTION>
<NAME>oseaserver_config_check_permissions</NAME>
<RETURNS>void  </RETURNS>
gchar * config_file
</FUNCTION>
<USER_FUNCTION>
<NAME>OseaClientPasswordNotifyCallback</NAME>
<RETURNS>void </RETURNS>
gchar *password, gpointer user_data
</USER_FUNCTION>
<TYPEDEF>
<NAME>OseaClientPasswordData</NAME>
typedef struct {
	OseaClientPasswordNotifyCallback notify_cb;
	gpointer user_data;
} OseaClientPasswordData;
</TYPEDEF>
<USER_FUNCTION>
<NAME>OseaClientPasswordCallback</NAME>
<RETURNS>gboolean </RETURNS>
OseaClientPasswordData * pwd_data
</USER_FUNCTION>
<FUNCTION>
<NAME>oseaclient_password_set_callback</NAME>
<RETURNS>void  </RETURNS>
OseaClientPasswordCallback cb
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_password_get</NAME>
<RETURNS>gboolean  </RETURNS>
OseaClientPasswordNotifyCallback notify_cb, gpointer user_data
</FUNCTION>
<MACRO>
<NAME>OSEACLIENT_TYPE_DATANODE</NAME>
#define OSEACLIENT_TYPE_DATANODE	(oseaclient_datanode_get_type())
</MACRO>
<MACRO>
<NAME>OSEACLIENT_DATANODE</NAME>
#define OSEACLIENT_DATANODE(obj)	G_TYPE_CHECK_INSTANCE_CAST((obj), oseaclient_datanode_get_type(), OseaClientDataNode)
</MACRO>
<MACRO>
<NAME>OSEACLIENT_DATANODE_CONST</NAME>
#define OSEACLIENT_DATANODE_CONST(obj)	G_TYPE_CHECK_INSTANCE_CAST((obj), oseaclient_datanode_get_type(), OseaClientDataNode const)
</MACRO>
<MACRO>
<NAME>OSEACLIENT_DATANODE_CLASS</NAME>
#define OSEACLIENT_DATANODE_CLASS(klass)	G_TYPE_CHECK_CLASS_CAST((klass), oseaclient_datanode_get_type(), OseaClientDataNodeClass)
</MACRO>
<MACRO>
<NAME>OSEACLIENT_IS_DATANODE</NAME>
#define OSEACLIENT_IS_DATANODE(obj)	G_TYPE_CHECK_INSTANCE_TYPE((obj), oseaclient_datanode_get_type ())
</MACRO>
<MACRO>
<NAME>OSEACLIENT_DATANODE_GET_CLASS</NAME>
#define OSEACLIENT_DATANODE_GET_CLASS(obj)	G_TYPE_INSTANCE_GET_CLASS((obj), oseaclient_datanode_get_type(), OseaClientDataNodeClass)
</MACRO>
<STRUCT>
<NAME>OseaClientDataNode</NAME>
</STRUCT>
<STRUCT>
<NAME>OseaClientDataNode</NAME>
struct OseaClientDataNode {
	GObject __parent__;
};
</STRUCT>
<STRUCT>
<NAME>OseaClientDataNodeClass</NAME>
</STRUCT>
<STRUCT>
<NAME>OseaClientDataNodeClass</NAME>
struct OseaClientDataNodeClass {
	GObjectClass __parent__;
	gboolean (* edit_wrapper) (OseaClientDataNode * self, AfDalNulFunc usr_function, gpointer usr_data);
	gboolean (* new_wrapper) (OseaClientDataNode * self, AfDalNulFunc usr_function, gpointer usr_data);
};
</STRUCT>
<FUNCTION>
<NAME>oseaclient_datanode_get_type</NAME>
<RETURNS>GType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_datanode_edit_wrapper</NAME>
<RETURNS>gboolean  </RETURNS>
OseaClientDataNode * self,AfDalNulFunc usr_function,gpointer usr_data
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_datanode_new_wrapper</NAME>
<RETURNS>gboolean  </RETURNS>
OseaClientDataNode * self,AfDalNulFunc usr_function,gpointer usr_data
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_decimal_stringfy</NAME>
<RETURNS>gchar         *</RETURNS>
OseaClientDecimal * decimal
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_decimal_free</NAME>
<RETURNS>void  </RETURNS>
OseaClientDecimal * decimal
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_decimal_new</NAME>
<RETURNS>OseaClientDecimal  *</RETURNS>
gchar * value
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_list_new</NAME>
<RETURNS>OseaClientList  *</RETURNS>
GCompareFunc compare_func
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_list_new_full</NAME>
<RETURNS>OseaClientList  *</RETURNS>
GCompareFunc compare_func,GDestroyNotify key_destroy_func,GDestroyNotify value_destroy_func
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_list_insert</NAME>
<RETURNS>void  </RETURNS>
OseaClientList *list, gpointer key, gpointer value
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_list_index</NAME>
<RETURNS>gint  </RETURNS>
OseaClientList *list, gpointer key
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_list_lookup</NAME>
<RETURNS>gpointer  </RETURNS>
OseaClientList *list, gpointer key
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_list_nth_data</NAME>
<RETURNS>gpointer  </RETURNS>
OseaClientList *list, gint n
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_list_length</NAME>
<RETURNS>guint  </RETURNS>
OseaClientList *list
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_list_remove</NAME>
<RETURNS>void  </RETURNS>
OseaClientList *list, gpointer key
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_list_foreach</NAME>
<RETURNS>void  </RETURNS>
OseaClientList *list, GTraverseFunc func, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_list_replace</NAME>
<RETURNS>void  </RETURNS>
OseaClientList *list, gpointer key, gpointer new_value
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_list_destroy</NAME>
<RETURNS>void  </RETURNS>
OseaClientList *list
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_list_first</NAME>
<RETURNS>void  </RETURNS>
OseaClientList *list
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_list_data</NAME>
<RETURNS>gpointer  </RETURNS>
OseaClientList *list
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_list_next</NAME>
<RETURNS>gboolean  </RETURNS>
OseaClientList *list
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_list_set_cursor_position</NAME>
<RETURNS>gboolean  </RETURNS>
OseaClientList *list, gint cursor_position
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_list_get_cursor_position</NAME>
<RETURNS>gint  </RETURNS>
OseaClientList *list
</FUNCTION>
<ENUM>
<NAME>OseaClientState</NAME>
typedef enum {OSEACLIENT_ERROR, 
	      OSEACLIENT_OK, 
	      OSEACLIENT_UPDATE_SERVICES_NEEDED,
	      OSEACLIENT_SESSION_EXPIRED
} OseaClientState;
</ENUM>
<STRUCT>
<NAME>_OseaClientMultiData</NAME>
struct _OseaClientMultiData {
	OseaClientState state;
	gchar     * text_response;
	GList     * multi_data;
};
</STRUCT>
<STRUCT>
<NAME>_OseaClientData</NAME>
struct _OseaClientData {
	OseaClientState  state;
	gchar     * text_response;
	OseaClientList     * data;  
};
</STRUCT>
<STRUCT>
<NAME>_OseaClientSimpleData</NAME>
struct _OseaClientSimpleData {
	OseaClientState  state;
	gchar     * text_response;
	gint        id;
};
</STRUCT>
<STRUCT>
<NAME>_OseaClientNulData</NAME>
struct _OseaClientNulData {
	OseaClientState  state;
	gchar     * text_response;
};
</STRUCT>
<ENUM>
<NAME>OseaClientRequestReturnData</NAME>
typedef enum {OSEACLIENT_REQUEST_MULTI_DATA,
	      OSEACLIENT_REQUEST_DATA, 
	      OSEACLIENT_REQUEST_SIMPLE_DATA, 
	      OSEACLIENT_REQUEST_NUL_DATA} OseaClientRequestReturnData;
</ENUM>
<USER_FUNCTION>
<NAME>OseaClientMultiFunc</NAME>
<RETURNS>gboolean </RETURNS>
OseaClientMultiData  * data, gpointer usr_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>OseaClientDataFunc</NAME>
<RETURNS>gboolean </RETURNS>
OseaClientData       * data, gpointer usr_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>OseaClientSimpleFunc</NAME>
<RETURNS>gboolean </RETURNS>
OseaClientSimpleData * data, gpointer usr_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>OseaClientNulFunc</NAME>
<RETURNS>gboolean </RETURNS>
OseaClientNulData    * data, gpointer usr_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>OseaClientFunc</NAME>
<RETURNS>gboolean </RETURNS>
gpointer          data, gpointer usr_data
</USER_FUNCTION>
<FUNCTION>
<NAME>oseaclient_nul_free</NAME>
<RETURNS>void  </RETURNS>
OseaClientNulData * data
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_simple_free</NAME>
<RETURNS>void  </RETURNS>
OseaClientSimpleData * data
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_data_free</NAME>
<RETURNS>void  </RETURNS>
OseaClientData * data, gboolean destroy_list
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_multi_free</NAME>
<RETURNS>void  </RETURNS>
OseaClientMultiData * data, gboolean destroy_lists
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_print_version_info</NAME>
<RETURNS>void  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>oseaclient_init</NAME>
<RETURNS>void  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>oseaclient_session_login</NAME>
<RETURNS>gboolean  </RETURNS>
gchar * usr,gchar * passwd,gchar * kernel_hostname,gchar * kernel_port,OseaClientNulFunc usr_function,gpointer usr_data
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_session_logout</NAME>
<RETURNS>gboolean  </RETURNS>
OseaClientNulFunc usr_function,gpointer usr_data
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_session_refresh_key</NAME>
<RETURNS>gboolean  </RETURNS>
gchar * server,OseaClientNulFunc usr_function,gpointer usr_data
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_session_refresh_session</NAME>
<RETURNS>gboolean  </RETURNS>
gchar * passwd,OseaClientNulFunc usr_function,gpointer usr_data
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_session_send_afkey</NAME>
<RETURNS>gboolean  </RETURNS>
gchar * server,OseaClientNulFunc usr_function,gpointer usr_data
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_session_register</NAME>
<RETURNS>gboolean  </RETURNS>
gchar * name,gint    version_number,gchar * host,gchar * port,gchar * kernel_hostname,gchar * kernel_port,OseaClientNulFunc usr_function,gpointer usr_data
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_session_unregister</NAME>
<RETURNS>gboolean  </RETURNS>
OseaClientNulFunc usr_function,gpointer usr_data
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_session_server_exists</NAME>
<RETURNS>gboolean  </RETURNS>
gchar *server_name
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_session_active_servers</NAME>
<RETURNS>GList          *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>oseaclient_session_server_free</NAME>
<RETURNS>void  </RETURNS>
OseaClientSessionServer *pserv
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_session_get_permission_list</NAME>
<RETURNS>GList          *</RETURNS>
gchar * server_name
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_session_free_permission_list</NAME>
<RETURNS>void  </RETURNS>
GList * permissions
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_session_get_permission</NAME>
<RETURNS>gboolean  </RETURNS>
gchar * server_name, gchar * permission_name
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_session_get_connection</NAME>
<RETURNS>RRConnection   *</RETURNS>
gchar *server_name,GError **error
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_session_delete_connection</NAME>
<RETURNS>void  </RETURNS>
gchar *server_name
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_session_new_connection</NAME>
<RETURNS>RRConnection   *</RETURNS>
gchar *server_name,GError **error
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_session_get_server_name</NAME>
<RETURNS>gchar          *</RETURNS>
RRConnection *connection,GError **error
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_request</NAME>
<RETURNS>gboolean  </RETURNS>
RRConnection * connection,OseaCommSimpleCfgCompleteMessage return_function,OseaClientFunc usr_function,gpointer usr_data,gchar * service_name,...
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_request_process_data</NAME>
<RETURNS>void  </RETURNS>
RRChannel * channel,RRFrame * frame,GString * message,gpointer data,gpointer custom_data
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_request_process_simple_data</NAME>
<RETURNS>void  </RETURNS>
RRChannel * channel,RRFrame * frame,GString * message,gpointer data,gpointer custom_data
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_request_process_nul_data</NAME>
<RETURNS>void  </RETURNS>
RRChannel * channel,RRFrame * frame,GString * message,gpointer data,gpointer custom_data
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_request_close_and_return_initial_data</NAME>
<RETURNS>gpointer  </RETURNS>
OseaClientRequestReturnData type,RRChannel * channel,RRFrame * frame,GString * message,OseaCommDataSet ** returned_dataset,GList ** returned_datasets,gpointer * data,gpointer * custom_data
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_request_start_afkey_refresh</NAME>
<RETURNS>gboolean  </RETURNS>
gpointer oseaclient_request_user_data
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_request_start_session_refresh</NAME>
<RETURNS>gboolean  </RETURNS>
gpointer oseaclient_request_user_data
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_request_call_user_function</NAME>
<RETURNS>void  </RETURNS>
OseaClientRequestReturnData type,gpointer handler,gpointer user_data,gpointer oseaclient_data
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_support_compare_id</NAME>
<RETURNS>gint  </RETURNS>
gconstpointer a, gconstpointer b
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_support_compare_string</NAME>
<RETURNS>gint  </RETURNS>
gconstpointer a, gconstpointer b
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_support_get_number</NAME>
<RETURNS>glong  </RETURNS>
const gchar * from_string
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_event_source_add_signal</NAME>
<RETURNS>void  </RETURNS>
gchar *signal_name
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_event_source_set_callback</NAME>
<RETURNS>guint  </RETURNS>
gchar *signal_name, GSourceFunc callback
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_event_source_emit_signal</NAME>
<RETURNS>void  </RETURNS>
gchar *signal_name, gpointer data
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_event_source_remove_signal</NAME>
<RETURNS>void  </RETURNS>
gchar *signal_name
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_event_source_exist</NAME>
<RETURNS>gboolean  </RETURNS>
gchar *signal_name
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_event_source_arm_signal</NAME>
<RETURNS>gchar   *</RETURNS>
gchar * signal_basename, GSourceFunc func
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_event_source_launch</NAME>
<RETURNS>void  </RETURNS>
GSourceFunc func, gpointer data
</FUNCTION>
<FUNCTION>
<NAME>oseaclient_event_source_print_pool</NAME>
<RETURNS>void  </RETURNS>

</FUNCTION>
<MACRO>
<NAME>OSEACLIENT_TYPE_KERNEL_GROUP</NAME>
#define OSEACLIENT_TYPE_KERNEL_GROUP	(aos_kernel_group_get_type())
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_GROUP</NAME>
#define AOS_KERNEL_GROUP(obj)	G_TYPE_CHECK_INSTANCE_CAST((obj), aos_kernel_group_get_type(), AosKernelGroup)
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_GROUP_CONST</NAME>
#define AOS_KERNEL_GROUP_CONST(obj)	G_TYPE_CHECK_INSTANCE_CAST((obj), aos_kernel_group_get_type(), AosKernelGroup const)
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_GROUP_CLASS</NAME>
#define AOS_KERNEL_GROUP_CLASS(klass)	G_TYPE_CHECK_CLASS_CAST((klass), aos_kernel_group_get_type(), AosKernelGroupClass)
</MACRO>
<MACRO>
<NAME>OSEACLIENT_IS_KERNEL_GROUP</NAME>
#define OSEACLIENT_IS_KERNEL_GROUP(obj)	G_TYPE_CHECK_INSTANCE_TYPE((obj), aos_kernel_group_get_type ())
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_GROUP_GET_CLASS</NAME>
#define AOS_KERNEL_GROUP_GET_CLASS(obj)	G_TYPE_INSTANCE_GET_CLASS((obj), aos_kernel_group_get_type(), AosKernelGroupClass)
</MACRO>
<STRUCT>
<NAME>AosKernelGroup</NAME>
</STRUCT>
<STRUCT>
<NAME>AosKernelGroup</NAME>
struct AosKernelGroup {
	OseaClientDataNode __parent__;
	/*< public >*/
	int id;
	char * name;
	char * description;
};
</STRUCT>
<STRUCT>
<NAME>AosKernelGroupClass</NAME>
</STRUCT>
<STRUCT>
<NAME>AosKernelGroupClass</NAME>
struct AosKernelGroupClass {
	OseaClientDataNodeClass __parent__;
};
</STRUCT>
<FUNCTION>
<NAME>aos_kernel_group_get_type</NAME>
<RETURNS>GType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_group_get_id</NAME>
<RETURNS>gint  </RETURNS>
AosKernelGroup * self
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_group_set_id</NAME>
<RETURNS>void  </RETURNS>
AosKernelGroup * self,gint val
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_group_get_name</NAME>
<RETURNS>gchar  *</RETURNS>
AosKernelGroup * self
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_group_set_name</NAME>
<RETURNS>void  </RETURNS>
AosKernelGroup * self,gchar * val
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_group_get_description</NAME>
<RETURNS>gchar  *</RETURNS>
AosKernelGroup * self
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_group_set_description</NAME>
<RETURNS>void  </RETURNS>
AosKernelGroup * self,gchar * val
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_group_create</NAME>
<RETURNS>AosKernelGroup  *</RETURNS>
gint id,gchar * name,gchar * description
</FUNCTION>
<MACRO>
<NAME>AOS_KERNEL_GROUP_PROP_ID</NAME>
#define AOS_KERNEL_GROUP_PROP_ID(arg)    	"id",({gint z = (arg); z;})
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_GROUP_GET_PROP_ID</NAME>
#define AOS_KERNEL_GROUP_GET_PROP_ID(arg)	"id",({gint *z = (arg); z;})
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_GROUP_PROP_NAME</NAME>
#define AOS_KERNEL_GROUP_PROP_NAME(arg)    	"name",({gchar *z = (arg); z;})
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_GROUP_GET_PROP_NAME</NAME>
#define AOS_KERNEL_GROUP_GET_PROP_NAME(arg)	"name",({gchar **z = (arg); z;})
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_GROUP_PROP_DESCRIPTION</NAME>
#define AOS_KERNEL_GROUP_PROP_DESCRIPTION(arg)    	"description",({gchar *z = (arg); z;})
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_GROUP_GET_PROP_DESCRIPTION</NAME>
#define AOS_KERNEL_GROUP_GET_PROP_DESCRIPTION(arg)	"description",({gchar **z = (arg); z;})
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_GROUP_PROP_ID</NAME>
#define AOS_KERNEL_GROUP_PROP_ID(arg)    	"id",(gint )(arg)
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_GROUP_GET_PROP_ID</NAME>
#define AOS_KERNEL_GROUP_GET_PROP_ID(arg)	"id",(gint *)(arg)
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_GROUP_PROP_NAME</NAME>
#define AOS_KERNEL_GROUP_PROP_NAME(arg)    	"name",(gchar *)(arg)
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_GROUP_GET_PROP_NAME</NAME>
#define AOS_KERNEL_GROUP_GET_PROP_NAME(arg)	"name",(gchar **)(arg)
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_GROUP_PROP_DESCRIPTION</NAME>
#define AOS_KERNEL_GROUP_PROP_DESCRIPTION(arg)    	"description",(gchar *)(arg)
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_GROUP_GET_PROP_DESCRIPTION</NAME>
#define AOS_KERNEL_GROUP_GET_PROP_DESCRIPTION(arg)	"description",(gchar **)(arg)
</MACRO>
<FUNCTION>
<NAME>aos_kernel_server_list</NAME>
<RETURNS>gboolean  </RETURNS>
gint           initial_server,gint           max_row_number,OseaClientDataFunc  usr_function,gpointer       usr_data
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_server_remove</NAME>
<RETURNS>gboolean  </RETURNS>
gint id,OseaClientNulFunc   usr_function,gpointer       usr_data
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_permission_list</NAME>
<RETURNS>gboolean  </RETURNS>
gint           initial_permission,gint           max_row_number,OseaClientDataFunc  usr_function,gpointer       usr_data
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_permission_list_by_user</NAME>
<RETURNS>gboolean  </RETURNS>
gint           initial_permission,gint           max_row_number,gint           user_id,OseaClientDataFunc  usr_function,gpointer       usr_data
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_permission_actual_list_by_user</NAME>
<RETURNS>gboolean  </RETURNS>
gint           initial_permission,gint           max_row_number,gint           user_id,OseaClientDataFunc  usr_function,gpointer       usr_data
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_permission_from_group_list_by_user</NAME>
<RETURNS>gboolean  </RETURNS>
gint           initial_permission,gint           max_row_number,gint           user_id,OseaClientDataFunc  usr_function,gpointer       usr_data
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_permission_list_by_group</NAME>
<RETURNS>gboolean  </RETURNS>
gint           initial_permission,gint           max_row_number,gint           group_id,OseaClientDataFunc  usr_function,gpointer       usr_data
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_permission_user_set</NAME>
<RETURNS>gboolean  </RETURNS>
gint           id,gint           user_id,OseaClientNulFunc   usr_function,gpointer       usr_data
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_permission_user_unset</NAME>
<RETURNS>gboolean  </RETURNS>
gint           id,gint           user_id,OseaClientNulFunc   usr_function,gpointer       usr_data
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_permission_user_set_value</NAME>
<RETURNS>gboolean  </RETURNS>
gint           id,gint           user_id,gboolean       value,OseaClientNulFunc   usr_func,gpointer       usr_data
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_permission_group_set</NAME>
<RETURNS>gboolean  </RETURNS>
gint           id,gint           group_id,OseaClientNulFunc   usr_function,gpointer       usr_data
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_permission_group_unset</NAME>
<RETURNS>gboolean  </RETURNS>
gint           id,gint           group_id,OseaClientNulFunc   usr_function,gpointer       usr_data
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_permission_group_set_value</NAME>
<RETURNS>gboolean  </RETURNS>
gint           id,gint           user_id,gboolean       value,OseaClientNulFunc   usr_func,gpointer       usr_data
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_register_get_servers</NAME>
<RETURNS>gboolean  </RETURNS>
OseaClientDataFunc  usr_function,gpointer       usr_data
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_group_list</NAME>
<RETURNS>gboolean  </RETURNS>
gint           initial_group,gint           max_row_number,OseaClientDataFunc  usr_function,gpointer       usr_data
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_group_new</NAME>
<RETURNS>gboolean  </RETURNS>
gchar           * name,gchar           * description,OseaClientSimpleFunc   usr_function,gpointer          usr_data
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_group_remove</NAME>
<RETURNS>gboolean  </RETURNS>
gint id,OseaClientNulFunc   usr_function,gpointer       usr_data
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_group_edit</NAME>
<RETURNS>gboolean  </RETURNS>
gint           id,gchar        * new_name,gchar        * new_description,OseaClientNulFunc   usr_function,gpointer       usr_data
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_group_add_user</NAME>
<RETURNS>gboolean  </RETURNS>
gint           group_id,gint           user_id,OseaClientNulFunc   usr_function,gpointer       usr_data
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_group_remove_user</NAME>
<RETURNS>gboolean  </RETURNS>
gint           group_id,gint           user_id,OseaClientNulFunc   usr_function,gpointer       usr_data
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_group_list_user</NAME>
<RETURNS>gboolean  </RETURNS>
gint           initial_group,gint           max_row_number,gint           group_id,OseaClientDataFunc  usr_function,gpointer       usr_data
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_user_list</NAME>
<RETURNS>gboolean  </RETURNS>
gint           initial_user,gint           max_row_number,OseaClientDataFunc  usr_function,gpointer       usr_data
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_user_new</NAME>
<RETURNS>gboolean  </RETURNS>
gchar           * nick,gchar           * password,gchar           * description,OseaClientSimpleFunc   usr_function,gpointer          usr_data
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_user_remove</NAME>
<RETURNS>gboolean  </RETURNS>
gint id,OseaClientNulFunc   usr_function,gpointer       usr_data
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_user_edit</NAME>
<RETURNS>gboolean  </RETURNS>
gint           id,gchar        * new_nick,gchar        * new_password,gchar        * new_description,OseaClientNulFunc   usr_function,gpointer       usr_data
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_user_list_group</NAME>
<RETURNS>gboolean  </RETURNS>
gint           initial_group,gint           max_row_number,gint           user_id,OseaClientDataFunc  usr_function,gpointer       usr_data
</FUNCTION>
<MACRO>
<NAME>OSEACLIENT_TYPE_KERNEL_USER</NAME>
#define OSEACLIENT_TYPE_KERNEL_USER	(aos_kernel_user_get_type())
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_USER</NAME>
#define AOS_KERNEL_USER(obj)	G_TYPE_CHECK_INSTANCE_CAST((obj), aos_kernel_user_get_type(), AosKernelUser)
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_USER_CONST</NAME>
#define AOS_KERNEL_USER_CONST(obj)	G_TYPE_CHECK_INSTANCE_CAST((obj), aos_kernel_user_get_type(), AosKernelUser const)
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_USER_CLASS</NAME>
#define AOS_KERNEL_USER_CLASS(klass)	G_TYPE_CHECK_CLASS_CAST((klass), aos_kernel_user_get_type(), AosKernelUserClass)
</MACRO>
<MACRO>
<NAME>OSEACLIENT_IS_KERNEL_USER</NAME>
#define OSEACLIENT_IS_KERNEL_USER(obj)	G_TYPE_CHECK_INSTANCE_TYPE((obj), aos_kernel_user_get_type ())
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_USER_GET_CLASS</NAME>
#define AOS_KERNEL_USER_GET_CLASS(obj)	G_TYPE_INSTANCE_GET_CLASS((obj), aos_kernel_user_get_type(), AosKernelUserClass)
</MACRO>
<STRUCT>
<NAME>AosKernelUser</NAME>
</STRUCT>
<STRUCT>
<NAME>AosKernelUser</NAME>
struct AosKernelUser {
	OseaClientDataNode __parent__;
	/*< public >*/
	int id;
	char * nick;
	char * description;
};
</STRUCT>
<STRUCT>
<NAME>AosKernelUserClass</NAME>
</STRUCT>
<STRUCT>
<NAME>AosKernelUserClass</NAME>
struct AosKernelUserClass {
	OseaClientDataNodeClass __parent__;
};
</STRUCT>
<FUNCTION>
<NAME>aos_kernel_user_get_type</NAME>
<RETURNS>GType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_user_get_id</NAME>
<RETURNS>gint  </RETURNS>
AosKernelUser * self
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_user_set_id</NAME>
<RETURNS>void  </RETURNS>
AosKernelUser * self,gint val
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_user_get_nick</NAME>
<RETURNS>gchar  *</RETURNS>
AosKernelUser * self
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_user_set_nick</NAME>
<RETURNS>void  </RETURNS>
AosKernelUser * self,gchar * val
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_user_get_description</NAME>
<RETURNS>gchar  *</RETURNS>
AosKernelUser * self
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_user_set_description</NAME>
<RETURNS>void  </RETURNS>
AosKernelUser * self,gchar * val
</FUNCTION>
<FUNCTION>
<NAME>aos_kernel_user_create</NAME>
<RETURNS>AosKernelUser  *</RETURNS>
gint id,gchar * nick,gchar * description
</FUNCTION>
<MACRO>
<NAME>AOS_KERNEL_USER_PROP_ID</NAME>
#define AOS_KERNEL_USER_PROP_ID(arg)    	"id",({gint z = (arg); z;})
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_USER_GET_PROP_ID</NAME>
#define AOS_KERNEL_USER_GET_PROP_ID(arg)	"id",({gint *z = (arg); z;})
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_USER_PROP_NICK</NAME>
#define AOS_KERNEL_USER_PROP_NICK(arg)    	"nick",({gchar *z = (arg); z;})
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_USER_GET_PROP_NICK</NAME>
#define AOS_KERNEL_USER_GET_PROP_NICK(arg)	"nick",({gchar **z = (arg); z;})
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_USER_PROP_DESCRIPTION</NAME>
#define AOS_KERNEL_USER_PROP_DESCRIPTION(arg)    	"description",({gchar *z = (arg); z;})
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_USER_GET_PROP_DESCRIPTION</NAME>
#define AOS_KERNEL_USER_GET_PROP_DESCRIPTION(arg)	"description",({gchar **z = (arg); z;})
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_USER_PROP_ID</NAME>
#define AOS_KERNEL_USER_PROP_ID(arg)    	"id",(gint )(arg)
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_USER_GET_PROP_ID</NAME>
#define AOS_KERNEL_USER_GET_PROP_ID(arg)	"id",(gint *)(arg)
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_USER_PROP_NICK</NAME>
#define AOS_KERNEL_USER_PROP_NICK(arg)    	"nick",(gchar *)(arg)
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_USER_GET_PROP_NICK</NAME>
#define AOS_KERNEL_USER_GET_PROP_NICK(arg)	"nick",(gchar **)(arg)
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_USER_PROP_DESCRIPTION</NAME>
#define AOS_KERNEL_USER_PROP_DESCRIPTION(arg)    	"description",(gchar *)(arg)
</MACRO>
<MACRO>
<NAME>AOS_KERNEL_USER_GET_PROP_DESCRIPTION</NAME>
#define AOS_KERNEL_USER_GET_PROP_DESCRIPTION(arg)	"description",(gchar **)(arg)
</MACRO>
<FUNCTION>
<NAME>aos_kernel_print_version_info</NAME>
<RETURNS>void  </RETURNS>

</FUNCTION>
<MACRO>
<NAME>OSEACOMM_SIMPLE_URI</NAME>
#define OSEACOMM_SIMPLE_URI "http://fact.aspl.es/profiles/oseacomm_profile"
</MACRO>
<STRUCT>
<NAME>OseaCommSimple</NAME>
</STRUCT>
<STRUCT>
<NAME>OseaCommSimpleClass</NAME>
</STRUCT>
<MACRO>
<NAME>TYPE_OSEACOMM_SIMPLE</NAME>
#define TYPE_OSEACOMM_SIMPLE (oseacomm_simple_get_type ())
</MACRO>
<MACRO>
<NAME>OSEACOMM_SIMPLE</NAME>
#define OSEACOMM_SIMPLE(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), TYPE_COYOTE_SIMPLE, OseaCommSimple))
</MACRO>
<MACRO>
<NAME>OSEACOMM_SIMPLE_CLASS</NAME>
#define OSEACOMM_SIMPLE_CLASS(class) (G_TYPE_CHECK_CLASS_CAST ((class), TYPE_COYOTE_SIMPLE, OseaCommSimpleClass))
</MACRO>
<MACRO>
<NAME>IS_OSEACOMM_SIMPLE</NAME>
#define IS_OSEACOMM_SIMPLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COYOTE_SIMPLE))
</MACRO>
<MACRO>
<NAME>IS_OSEACOMM_SIMPLE_CLASS</NAME>
#define IS_OSEACOMM_SIMPLE_CLASS(class) (G_TYPE_CHECK_CLASS_TYPE ((class), TYPE_COYOTE_SIMPLE))
</MACRO>
<MACRO>
<NAME>OSEACOMM_SIMPLE_GET_CLASS</NAME>
#define OSEACOMM_SIMPLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COYOTE_SIMPLE, OseaCommSimpleClass))
</MACRO>
<STRUCT>
<NAME>OseaCommSimple</NAME>
struct OseaCommSimple {
	RRChannel parent_object;
	GByteArray * buffer;
	gboolean finish_connection;
};
</STRUCT>
<STRUCT>
<NAME>OseaCommSimpleClass</NAME>
struct OseaCommSimpleClass {
	RRChannelClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>oseacomm_simple_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_simple_start</NAME>
<RETURNS>OseaCommSimple  *</RETURNS>
RRConnection * connection,OseaCommSimpleCfg * config,GError ** error
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_simple_close</NAME>
<RETURNS>gboolean  </RETURNS>
OseaCommSimple * channel,GError ** error
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_simple_send</NAME>
<RETURNS>gboolean  </RETURNS>
OseaCommSimple * channel,gchar * data,gint len, gint free,GError ** error
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_simple_reply</NAME>
<RETURNS>gboolean  </RETURNS>
OseaCommSimple * channel,gchar * data, gint len,gint msg_no, gint free,GError ** error
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_simple_reply_error</NAME>
<RETURNS>gboolean  </RETURNS>
OseaCommSimple * channel,gchar * data, gint len,gint msg_no, gint free,GError ** error
</FUNCTION>
<STRUCT>
<NAME>OseaCommXmlObject</NAME>
</STRUCT>
<STRUCT>
<NAME>OseaCommXmlMessage</NAME>
</STRUCT>
<STRUCT>
<NAME>OseaCommXmlServiceData</NAME>
</STRUCT>
<STRUCT>
<NAME>OseaCommXmlServiceNode</NAME>
</STRUCT>
<ENUM>
<NAME>OseaCommXmlServiceType</NAME>
typedef enum {OSEACOMM_XML_SERVICE_REQUEST, COYOTE_XML_SERVICE_RESPONSE} OseaCommXmlServiceType;
</ENUM>
<ENUM>
<NAME>OseaCommXmlArgType</NAME>
typedef enum {OSEACOMM_XML_ARG_STRING, COYOTE_XML_ARG_DATASET} OseaCommXmlArgType;
</ENUM>
<STRUCT>
<NAME>OseaCommXmlMessage</NAME>
struct OseaCommXmlMessage {
	gchar *content;
	gint len;
};
</STRUCT>
<STRUCT>
<NAME>OseaCommXmlServiceNode</NAME>
struct OseaCommXmlServiceNode {
	gchar * attrib;
	OseaCommXmlArgType type;
	gpointer value;
};
</STRUCT>
<STRUCT>
<NAME>OseaCommXmlServiceData</NAME>
struct OseaCommXmlServiceData {
	OseaCommXmlServiceType type;
	gchar * name;
	gchar * protocol_version;
	gchar * status;
	gchar * status_message;
	GList * item_list;
};
</STRUCT>
<FUNCTION>
<NAME>oseacomm_xml_new_object</NAME>
<RETURNS>OseaCommXmlObject  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_xml_destroy_object</NAME>
<RETURNS>void  </RETURNS>
OseaCommXmlObject * object
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_xml_add_request_service</NAME>
<RETURNS>void  </RETURNS>
OseaCommXmlObject * object,gchar * name_of_service,...
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_xml_add_vrequest_service</NAME>
<RETURNS>void  </RETURNS>
OseaCommXmlObject * object,gchar * name_of_service,va_list args
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_xml_add_response_service</NAME>
<RETURNS>void  </RETURNS>
OseaCommXmlObject * object,CoyoteCodeType status_code,gchar * explanation,...
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_xml_add_vresponse_service</NAME>
<RETURNS>void  </RETURNS>
OseaCommXmlObject * object,CoyoteCodeType status_code,gchar * explanation,va_list args
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_xml_validate_message</NAME>
<RETURNS>gboolean  </RETURNS>
OseaCommXmlMessage * message
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_xml_parse_message</NAME>
<RETURNS>OseaCommXmlServiceData  *</RETURNS>
OseaCommXmlMessage * message
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_xml_parse_destroy</NAME>
<RETURNS>void  </RETURNS>
OseaCommXmlServiceData * data
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_xml_build_message</NAME>
<RETURNS>OseaCommXmlMessage  *</RETURNS>
OseaCommXmlObject * object
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_xml_destroy_message</NAME>
<RETURNS>void  </RETURNS>
OseaCommXmlMessage * message
</FUNCTION>
<ENUM>
<NAME>OseaCommCodeType</NAME>
typedef enum {OSEACOMM_CODE_OK, 
	      OSEACOMM_CODE_ERROR, 
	      OSEACOMM_CODE_UNKNOWN_SERVICE,
	      OSEACOMM_CODE_XML_VALIDATION_PROBLEM,
	      OSEACOMM_CODE_XML_PARSE_PROBLEM,
	      OSEACOMM_CODE_XML_INCORRECT_PARAMETER,
	      OSEACOMM_CODE_KEY_REQUIRED,
	      OSEACOMM_CODE_KEY_EXPIRED,
	      OSEACOMM_CODE_KEY_INVALID,
	      OSEACOMM_CODE_INSUFFICIENT_PERMISSIONS,
	      OSEACOMM_CODE_SERVICES_UPDATE_NEEDED,
	      OSEACOMM_CODE_SESSION_EXPIRED,
	      OSEACOMM_CODE_UNKNOWN_CODE              // This code must be the last one always
} OseaCommCodeType;
</ENUM>
<STRUCT>
<NAME>OseaCommCode</NAME>
struct OseaCommCode {
	gchar *status_code;
	gchar *status_text;
};
</STRUCT>
<STRUCT>
<NAME>OseaCommCode</NAME>
</STRUCT>
<FUNCTION>
<NAME>oseacomm_code_get_type</NAME>
<RETURNS>OseaCommCodeType  </RETURNS>
gchar *status
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_code_get_status</NAME>
<RETURNS>const gchar    *</RETURNS>
OseaCommCodeType type
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_code_new</NAME>
<RETURNS>OseaCommCode     *</RETURNS>
OseaCommCodeType type, const gchar *extended_message
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_code_free</NAME>
<RETURNS>void  </RETURNS>
OseaCommCode *code
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_init</NAME>
<RETURNS>gboolean  </RETURNS>
gint *argc, gchar ***argv, GError **error
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_exit</NAME>
<RETURNS>gboolean  </RETURNS>
GError **error
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_dataset_new</NAME>
<RETURNS>OseaCommDataSet  *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>oseacomm_dataset_get</NAME>
<RETURNS>const gchar  *</RETURNS>
OseaCommDataSet * data,gint row,gint col
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_dataset_set</NAME>
<RETURNS>gboolean  </RETURNS>
OseaCommDataSet * dataset,gchar * data,gint row,gint col
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_dataset_add</NAME>
<RETURNS>void  </RETURNS>
OseaCommDataSet * data, gchar * user_data
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_dataset_add_nth</NAME>
<RETURNS>void  </RETURNS>
OseaCommDataSet * data, ...
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_dataset_new_row</NAME>
<RETURNS>void  </RETURNS>
OseaCommDataSet * data
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_dataset_get_height</NAME>
<RETURNS>gint  </RETURNS>
OseaCommDataSet * data
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_dataset_get_width</NAME>
<RETURNS>gint  </RETURNS>
OseaCommDataSet * data
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_dataset_lookup_row</NAME>
<RETURNS>gint  </RETURNS>
OseaCommDataSet * data, gint column, const gchar *value
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_dataset_free</NAME>
<RETURNS>void  </RETURNS>
OseaCommDataSet * data
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_dataset_print</NAME>
<RETURNS>void  </RETURNS>
OseaCommDataSet * data
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_connection_new</NAME>
<RETURNS>RRConnection  *</RETURNS>
gchar * server, gchar * port, gint connection_profile
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_connection_get_client_name</NAME>
<RETURNS>gchar         *</RETURNS>
RRChannel * channel
</FUNCTION>
<STRUCT>
<NAME>OseaCommSimpleCfg</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>OseaCommSimpleCfgFrameAvailable</NAME>
<RETURNS>gboolean </RETURNS>
RRChannel *channel, 
							  RRFrame *frame, 
							  GError **error
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>OseaCommSimpleCfgCloseConfirmation</NAME>
<RETURNS>void </RETURNS>
RRChannel *channel, gint code,
							  const gchar *xml_lang, 
							  const gchar *diagnostic
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>OseaCommSimpleCfgCloseIndication</NAME>
<RETURNS>gboolean </RETURNS>
RRChannel *channel, gint code,
							  const gchar *xml_lang, 
							  const gchar *diagnostic,
							  GError **error
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>OseaCommSimpleCfgClientInit</NAME>
<RETURNS>gboolean </RETURNS>
RRChannel *channel, 
							  GError **error
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>OseaCommSimpleCfgServerInit</NAME>
<RETURNS>gboolean </RETURNS>
RRChannel *channel, 
							  const gchar *piggyback, 
							  GError **error
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>OseaCommSimpleCfgClientConfirmation</NAME>
<RETURNS>void </RETURNS>
RRChannel *channel, 
							  const gchar *piggyback
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>OseaCommSimpleCfgServerConfirmation</NAME>
<RETURNS>void </RETURNS>
RRChannel *channel
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>OseaCommSimpleCfgFinalize</NAME>
<RETURNS>void </RETURNS>
RRChannel *channel
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>OseaCommSimpleCfgCompleteMessage</NAME>
<RETURNS>void </RETURNS>
RRChannel *channel, 
							  RRFrame *frame,
							  GString *text, 
							  gpointer  data, 
							  gpointer custom_data 
</USER_FUNCTION>
<STRUCT>
<NAME>OseaCommSimpleCfg</NAME>
struct OseaCommSimpleCfg {
	OseaCommSimpleCfgFrameAvailable      frame_available_cb;
	
	OseaCommSimpleCfgCloseConfirmation   close_confirmation_cb;

	OseaCommSimpleCfgCloseIndication     close_indication_cb;

	OseaCommSimpleCfgClientInit          client_init_cb;

	OseaCommSimpleCfgServerInit          server_init_cb;

	OseaCommSimpleCfgClientConfirmation  client_confirmation_cb;

	OseaCommSimpleCfgServerConfirmation  server_confirmation_cb;

	OseaCommSimpleCfgFinalize            finalize_cb;


	OseaCommSimpleCfgCompleteMessage     complete_message_cb;
	
	gpointer  server_init_data;
	gpointer  complete_message_data;
	gpointer  complete_message_custom_data;
	
	GByteArray *buffer;
	gint buffer_len;
};
</STRUCT>
<FUNCTION>
<NAME>oseacomm_simple_cfg_new</NAME>
<RETURNS>OseaCommSimpleCfg  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_simple_cfg_destroy</NAME>
<RETURNS>void 	</RETURNS>
OseaCommSimpleCfg *config
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_simple_cfg_set_frame_available</NAME>
<RETURNS>void  </RETURNS>
OseaCommSimpleCfg *config,CoyoteSimpleCfgFrameAvailable cb
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_simple_cfg_set_close_indication</NAME>
<RETURNS>void  </RETURNS>
OseaCommSimpleCfg *config,CoyoteSimpleCfgCloseIndication cb
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_simple_cfg_set_close_confirmation</NAME>
<RETURNS>void  </RETURNS>
OseaCommSimpleCfg *config,CoyoteSimpleCfgCloseConfirmation cb
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_simple_cfg_set_finalize</NAME>
<RETURNS>void  </RETURNS>
OseaCommSimpleCfg *config,CoyoteSimpleCfgFinalize cb
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_simple_cfg_set_server_init</NAME>
<RETURNS>void  </RETURNS>
OseaCommSimpleCfg *config,CoyoteSimpleCfgServerInit cb,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_simple_cfg_set_server_confirm</NAME>
<RETURNS>void  </RETURNS>
OseaCommSimpleCfg *config,CoyoteSimpleCfgServerConfirmation cb
</FUNCTION>
<FUNCTION>
<NAME>oseacomm_simple_cfg_set_complete_message</NAME>
<RETURNS>void  </RETURNS>
OseaCommSimpleCfg * config,CoyoteSimpleCfgCompleteMessage cb,gpointer data,gpointer custom_data
</FUNCTION>
