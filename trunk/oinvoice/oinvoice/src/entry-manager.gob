%alltop{
/*
 *
 *  LibAfdalTax: interface library to the tax daemon
 *  Copyright (C) 2002, 2003 Advanced Software Production Line, S.L.
 *  Copyright (C) 2004 David Marín Carreño
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
%}
%header{
#include <afdal/afdal.h>
#include <gtk/gtkentry.h>
#include <gtk/gtkwindow.h>
#include <glade/glade.h>	
#include "aspl_listmodel.h"
#include "support.h"
#include "aspl_datalist.h"
#include "transaction_progress_window.h"
%} 

requires 2.0.0
 
%{
#include <glib.h>
#include "entry-manager.h"
#include "main_window.h"
#include "widgets.h"
#ifdef HAVE_LOCALE_H
#include <locale.h>
#endif
 
#ifdef ENABLE_NLS
#include <libintl.h>
#define _(String) gettext (String)
#else
#define _(String) (String)
#endif

%}

class Entry:Manager from G:Object {
	// Type declaration
	private GList    * objects        = NULL
		destroywith g_list_free;
	
	private GladeXML * main_glade     = NULL
		destroywith g_object_unref;

	private GtkWindow * parent_window = NULL;

	private gchar * window_name       = NULL
		destroywith g_free;

	private GtkWidget * main_entry    = NULL;

	private AfDalDataNode * node  = NULL;


	private AsplListmodel * model = NULL;
	
	private GtkTreeIter   * iter  = NULL;

	// Internal object gtk callbacks
	private void entry_changed (GtkEntry * entry, EntryManagerPrivate * priv) {
		
		
	}
	

	private void change_title (GtkEntry * entry, EntryManagerPrivate * priv) {
		const gchar * text;
		gchar       * title;
		GtkWidget   * widget = NULL;
		
		text = gtk_entry_get_text (entry);
		widget = glade_xml_get_widget (priv->main_glade, priv->window_name);
		
		if (!text || !text[0])
			gtk_window_set_title (GTK_WINDOW(widget), (const gchar *) g_strdup ("ASPL Fact"));
		else {
			title = g_strdup_printf (_("%s - ASPL Fact"), text);
			gtk_window_set_title (GTK_WINDOW(widget), (const gchar *) title);
		}
		return;
	}

	private void button_ok_clicked_process (AsplDataList * datalist) {
		AfDalNulData              * data     = aspl_datalist_get (datalist, "DATA");
		GtkWindow                 * window;
		EntryManager              * entry    = aspl_datalist_get (datalist, "ENTRYMANAGER");
		gboolean                    is_edit  = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (entry), "edit"));

		// Shutdown transaction progress window
		transaction_progress_window_destroy ();

		window = GTK_WINDOW (glade_xml_get_widget (entry->_priv->main_glade,
							   entry->_priv->window_name));
		
		gtk_widget_hide (GTK_WIDGET (window));

		// Check what happens
		if (data->state == AFDAL_ERROR) {
			dialog_close_run (window, GTK_MESSAGE_ERROR, 
					  _("There was a problem while %s:\n%s"), 
					  is_edit ? "editing" : "creating" ,
					  data->text_response);
			afdal_nul_free (data);
			return;
		}
		
		if (is_edit) {
			aspl_listmodel_edit_node (ASPL_LISTMODEL (entry->_priv->model), 
						  entry->_priv->iter,
						  entry->_priv->node);
		}else
			aspl_listmodel_insert_node (ASPL_LISTMODEL (entry->_priv->model),
						    entry->_priv->node);
		return;
	}
	
	private void button_ok_clicked (GtkButton * button, EntryManager * entry) {
		GList         * list_aux       = NULL;
		GtkWidget     * widget         = NULL;
		GtkTextBuffer * txtbuf         = NULL;
		GtkWindow     * window         = NULL;
		gchar         * string_aux     = NULL;
		GParamSpec   ** paramspecs     = NULL;
		GObjectClass  * object_class   = NULL;
		AsplDataList  * datalist       = NULL;
		gint            param_number   = 0;
		gint            i              = 0;
		GtkTextIter     iter1;
		GtkTextIter     iter2;
		GValue          value_string = {0, };
		gboolean        is_edit        = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (entry), "edit"));

		g_value_init (&value_string, G_TYPE_STRING);

		window = GTK_WINDOW (glade_xml_get_widget (entry->_priv->main_glade,
							   entry->_priv->window_name));

		object_class = G_OBJECT_CLASS (AFDAL_DATANODE_GET_CLASS (entry->_priv->node));
		
		paramspecs = g_object_class_list_properties (object_class, &param_number);

		// Check if every data was set
		for (list_aux = g_list_first (entry->_priv->objects); list_aux;  list_aux = g_list_next (list_aux)) {
			
			widget = list_aux->data;

			// Get text string holded 
			if (GTK_IS_ENTRY (widget)) {
				string_aux = g_strdup (gtk_entry_get_text (GTK_ENTRY (widget)));
				
			}else {
				txtbuf = gtk_text_view_get_buffer (GTK_TEXT_VIEW (widget));
				gtk_text_buffer_get_start_iter (txtbuf, &iter1);
				gtk_text_buffer_get_end_iter (txtbuf, &iter2);
				string_aux = g_strdup (gtk_text_buffer_get_text (txtbuf, &iter1,  &iter2,  FALSE));
			}
			
			// Check if value was set
			if (!(string_aux && (* string_aux))) {
				dialog_close_run (window, GTK_MESSAGE_ERROR, _("You must provide a valid %s"), 
						  paramspecs[i]->name);
				return;
			}
			
			// Set to the object property
			if (G_IS_PARAM_SPEC_STRING (paramspecs[i + 1])) {
				g_value_set_string (&value_string,  string_aux);
				g_object_set_property (G_OBJECT (entry->_priv->node),  paramspecs[i + 1]->name, 
						       &value_string);
			}else {
				g_critical ("Int paramspec not supported!!\n");
			}
					
			i++;
			if (i > param_number) {
				g_critical ("Param number (exceeded) goes to cuenca.");
				return;
			}
		}
		
		datalist = support_create_callback (entry_manager_button_ok_clicked_process);
		aspl_datalist_set (datalist, "ENTRYMANAGER", entry);

		if (is_edit) {
			if (!afdal_datanode_edit_wrapper (entry->_priv->node, event_process_afdal_nuldata, datalist))
				dialog_close_run (main_window_get (), GTK_MESSAGE_ERROR,
						  _("There was a problem while editing"));
		}else {
			if (!afdal_datanode_new_wrapper (entry->_priv->node, event_process_afdal_nuldata, datalist))
				dialog_close_run (main_window_get (), GTK_MESSAGE_ERROR,
						  _("There was a problem while creating"));
		}
			
				

		transaction_progress_window_show (window, _("Creating.."), NULL);
		
		return;
	}

	private void button_cancel_clicked (GtkButton * button, EntryManager * entry) {
					
		GtkWidget * widget = glade_xml_get_widget (entry->_priv->main_glade,
							   entry->_priv->window_name);

		
		gtk_widget_hide (widget);

		return;
	}

	private gboolean window_destroy (GtkWindow * window, EntryManager * manager) {
		
		return FALSE;
	}

	// Method declaration
	public void attach_entry (self,  gchar * entry_name (check null), gboolean focus) {
		GtkWidget * entry_widget;

		entry_widget = glade_xml_get_widget (self->_priv->main_glade, entry_name);
		g_return_if_fail (entry_widget);

		self->_priv->objects = g_list_append (self->_priv->objects, entry_widget);
		
		g_signal_connect (entry_widget, "activate", G_CALLBACK (entry_manager_entry_changed), selfp);
		if (focus) {
			// This widget got the focus so is the main actor
			gtk_widget_grab_focus (GTK_WIDGET (entry_widget));	
			g_signal_connect (entry_widget, "changed", 
					  G_CALLBACK (entry_manager_change_title), selfp);

			
		}
		return;
	}

	public void attach_txtbuf (self, gchar * txtbuf_name (check null), gboolean focus) {
		GtkWidget * txtbuf_widget;
	
		txtbuf_widget = glade_xml_get_widget (self->_priv->main_glade, txtbuf_name);
		g_return_if_fail (txtbuf_widget);

		self->_priv->objects = g_list_append (self->_priv->objects, txtbuf_widget);
		if (focus)
			gtk_widget_grab_focus (GTK_WIDGET (txtbuf_widget));	
		return;
	}
	
	private void connect_signals (self) {
		gchar     * button_ok_name;
		gchar     * button_cancel_name;
		GtkWidget * button_ok;
		GtkWidget * button_cancel;
		GtkWindow * window;

		// Conect button ok callback
		button_ok_name = g_strdup_printf ("%s_button_ok", self->_priv->window_name);
		button_ok = glade_xml_get_widget (self->_priv->main_glade, button_ok_name);
		if (GTK_IS_BUTTON (button_ok)) {
			g_signal_connect (button_ok, "clicked", 
					  G_CALLBACK (entry_manager_button_ok_clicked), self);			
		}else {
			g_critical ("Unable to find predefined button %s for window %s",
				    button_ok_name, self->_priv->window_name);
		}

		// Connect button cancel callback
		button_cancel_name = g_strdup_printf ("%s_button_cancel", self->_priv->window_name);
		button_cancel = glade_xml_get_widget (self->_priv->main_glade, button_cancel_name);
		if (GTK_IS_BUTTON (button_cancel)) {
			g_signal_connect (button_cancel, "clicked", 
					  G_CALLBACK (entry_manager_button_cancel_clicked), self);			
		}else {
			g_critical ("Unable to find predefined button %s for window %s",
				    button_cancel_name, self->_priv->window_name);
		}

		window = GTK_WINDOW (glade_xml_get_widget (self->_priv->main_glade,
							   self->_priv->window_name));

		// Connect delete_event.
		g_signal_connect (GTK_WIDGET (window), "delete_event",
				  G_CALLBACK (entry_manager_window_destroy), self);
		
		g_free (button_ok_name);
		g_free (button_cancel_name);
		
		return;
	}
	
	public void load (self, Aspl:Listmodel * model (check null type), GtkTreeIter iter) {
		GtkWidget      * window;
		GtkWidget      * entry;
		GtkTextBuffer  * buffer;
		AfDalDataNode  * node;
		GParamSpec    ** paramspecs   = NULL;
		GObjectClass   * object_class = NULL;
		gint             param_number = 0;
		gint             i;
		gchar          * text;
		GValue           value_string = {0, };
		GValue           value_int = {0, };

		g_value_init (&value_string, G_TYPE_STRING);
		g_value_init (&value_int, G_TYPE_INT);

		window = glade_xml_get_widget (self->_priv->main_glade, self->_priv->window_name);
		
		gtk_window_set_transient_for (GTK_WINDOW (window), main_window_get ());
		main_window_set_active_window (GTK_WINDOW (window));

		// Before launch window, fill it with data
		node = aspl_listmodel_get_node (model, &iter);
		g_return_if_fail (AFDAL_IS_DATANODE (node));		

		self->_priv->node = node;
		self->_priv->model = model;
		self->_priv->iter = &iter;


		// Load text into entry widgets
		object_class = G_OBJECT_CLASS (AFDAL_DATANODE_GET_CLASS (node));
		paramspecs = g_object_class_list_properties (object_class, &param_number);

		for (i = 0; i < param_number; i++) {
			if (!g_strcasecmp (paramspecs[i]->name, "id"))
				continue;
			
			if (G_IS_PARAM_SPEC_STRING (paramspecs[i])) {
				g_object_get_property (G_OBJECT(node), paramspecs[i]->name, &value_string);
				text = (gchar *) g_value_get_string (&value_string);
				entry = g_list_nth_data (self->_priv->objects, i - 1);

				if (GTK_IS_ENTRY (entry)) {
					gtk_entry_set_text (GTK_ENTRY (entry), text);
				}else {
					buffer = gtk_text_view_get_buffer (GTK_TEXT_VIEW (entry));
					gtk_text_buffer_set_text (buffer, text, -1);
				}
			}else 
				g_critical ("Not a string param spec\n");
		}
		
		// Connect signals
		entry_manager_connect_signals (self);
		g_object_set_data (G_OBJECT (self), "edit", GINT_TO_POINTER (TRUE));
		gtk_widget_show (window);
		return;				
	}	
	
	public void start (self, Aspl:Listmodel * model (check null type)) {
		GtkWidget * window;

		window = glade_xml_get_widget (self->_priv->main_glade, self->_priv->window_name);
		gtk_window_set_transient_for (GTK_WINDOW (window), main_window_get ());
		main_window_set_active_window (GTK_WINDOW (window));

		self->_priv->node = g_object_new (aspl_listmodel_get_node_type (model), NULL);
		self->_priv->model = model;

		entry_manager_connect_signals (self);
		gtk_widget_show (window);
		return;
	}



	public Entry:Manager * new (gchar * xml_file (check null), 
				    gchar * window_name (check null),
				    Gtk:Window * parent_window (check null type)) {

		EntryManager * em = GET_NEW;

		em->_priv->main_glade = widgets_load (xml_file, window_name, NULL);
		em->_priv->window_name = g_strdup (window_name);
		em->_priv->parent_window = parent_window;

		return em;
	}

}
